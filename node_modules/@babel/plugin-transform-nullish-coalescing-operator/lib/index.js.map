{"version":3,"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","loose","_api$assumption","assertVersion","noDocumentAll","assumption","name","inherits","version","undefined","visitor","LogicalExpression","path","node","scope","operator","ref","assignment","isStatic","left","t","cloneNode","isPattern","replaceWith","template","statement","ast","generateUidIdentifierBasedOnNode","push","id","assignmentExpression","conditionalExpression","binaryExpression","nullLiteral","logicalExpression","buildUndefinedNode","right"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, template } from \"@babel/core\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, { loose = false }: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? loose;\n\n  return {\n    name: \"transform-nullish-coalescing-operator\",\n    inherits:\n      USE_ESM || IS_STANDALONE || api.version[0] === \"8\"\n        ? undefined\n        : // eslint-disable-next-line no-restricted-globals\n          require(\"@babel/plugin-syntax-nullish-coalescing-operator\").default,\n\n    visitor: {\n      LogicalExpression(path) {\n        const { node, scope } = path;\n        if (node.operator !== \"??\") {\n          return;\n        }\n\n        let ref;\n        let assignment;\n        // skip creating extra reference when `left` is static\n        if (scope.isStatic(node.left)) {\n          ref = node.left;\n          assignment = t.cloneNode(node.left);\n        } else if (scope.path.isPattern()) {\n          // Replace `function (a, x = a.b ?? c) {}` to `function (a, x = (() => a.b ?? c)() ){}`\n          // so the temporary variable can be injected in correct scope\n          path.replaceWith(template.statement.ast`(() => ${path.node})()`);\n          // 